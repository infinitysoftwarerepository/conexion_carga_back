===== APP DUMP 2025-11-12 20:33:14 UTC =====
PROJECT ROOT: /opt/apps/conexion_carga_back

.
backups
backups/security_2025-10-21_161715.py
backups/security_2025-10-21_155406.py
backups/security_2025-10-21_160708.py
backups/security_2025-10-21_160647.py
requirements.txt
db_schema_all.sql
dump_app.sh
app
app/routers
app/routers/auth.py
app/routers/users.py
app/routers/catalogos.py
app/routers/loads.py
app/main.py
app/services
app/services/emailer.py
app/services/__init__.py
app/crud.py
app/emailer.py
app/models.py
app/schemas.py
app/__init__.py
app/security.py
app/db.py
.gitignore
app_completa.txt
.env


----- BEGIN FILE: ./app_completa.txt -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app_completa.txt


----- END FILE: ./app_completa.txt -----

----- BEGIN FILE: ./app/crud.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/crud.py

# app/crud.py
from __future__ import annotations
from typing import List, Optional
from uuid import UUID
from datetime import timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, or_

from . import models, schemas
from .security import get_password_hash

# ---------- USERS ----------
def get_users(db: Session, skip: int = 0, limit: int = 100) -> List[models.User]:
    return (
        db.query(models.User)
        .order_by(models.User.created_at.desc())
        .offset(skip).limit(limit).all()
    )

def get_user(db: Session, user_id: UUID) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    return (
        db.query(models.User)
        .filter(func.lower(models.User.email) == func.lower(email.strip()))
        .first()
    )

def create_user(db: Session, user_in: schemas.UserCreate, password_hash: str,
                referred_by_id: Optional[UUID] = None) -> models.User:
    u = models.User(
        email=user_in.email.strip(),
        first_name=user_in.first_name,
        last_name=user_in.last_name,
        phone=user_in.phone,
        is_company=user_in.is_company,
        company_name=user_in.company_name if user_in.is_company else None,
        password_hash=password_hash,
        active=False,
        referred_by_id=referred_by_id,
    )
    db.add(u); db.commit(); db.refresh(u)
    return u

def update_user(db: Session, user_id: UUID, user_in: schemas.UserUpdate) -> Optional[models.User]:
    u = get_user(db, user_id)
    if not u:
        return None
    for attr in ("email","first_name","last_name","phone","is_company","company_name"):
        val = getattr(user_in, attr, None)
        if val is not None:
            setattr(u, attr, val)
    if user_in.is_company is False:
        u.company_name = None
    if user_in.password:
        u.password_hash = get_password_hash(user_in.password)
    db.add(u); db.commit(); db.refresh(u)
    return u

# ---------- CARGAS ----------
def create_cargo(db: Session, data: schemas.CargoCreate, comercial_id):
    obj = models.Cargo(
        empresa_id=data.empresa_id,
        origen=data.origen,
        destino=data.destino,
        tipo_carga=data.tipo_carga,
        peso=data.peso,
        valor=data.valor,
        comercial_id=comercial_id,
        comercial=data.comercial,
        contacto=data.contacto,
        observaciones=data.observaciones,
        conductor=data.conductor,
        # vehiculo_id=data.vehiculo_id,  # ‚ùå ELIMINADO
        tipo_vehiculo=data.tipo_vehiculo,
        duracion_publicacion=timedelta(hours=int(data.duration_hours or 24)),
        activo=True,
        premium_trip=getattr(data, "premium_trip", False),
    )
    db.add(obj); db.commit(); db.refresh(obj)
    return obj

def get_cargo(db: Session, cargo_id: UUID) -> Optional[models.Cargo]:
    return db.query(models.Cargo).filter(models.Cargo.id == cargo_id).first()

def get_public_cargas(db: Session, skip=0, limit=100) -> List[models.Cargo]:
    return (
        db.query(models.Cargo)
        .filter(models.Cargo.estado == "publicado", models.Cargo.activo.is_(True))
        .order_by(models.Cargo.created_at.desc())
        .offset(skip).limit(limit).all()
    )

def get_my_cargas(db: Session, comercial_id, status: str = "all", skip=0, limit=100):
    q = db.query(models.Cargo).filter(models.Cargo.comercial_id == comercial_id)
    if status == "published":
        q = q.filter(models.Cargo.estado == "publicado", models.Cargo.activo.is_(True))
    elif status == "expired":
        q = q.filter(or_(models.Cargo.estado == "caducado",
                         models.Cargo.estado == "eliminado",
                         models.Cargo.activo.is_(False)))
    return (
        q.order_by(models.Cargo.created_at.desc())
         .offset(skip).limit(limit).all()
    )

def expire_cargo(db: Session, cargo_id: UUID, owner_id: UUID) -> Optional[models.Cargo]:
    c = get_cargo(db, cargo_id)
    if not c or c.comercial_id != owner_id:
        return None
    c.estado = "caducado"
    c.activo = False
    db.add(c); db.commit(); db.refresh(c)
    return c

----- END FILE: ./app/crud.py -----

----- BEGIN FILE: ./app/db.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/db.py

import os
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

load_dotenv()

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql+psycopg2://infinity:infinity@localhost/conexion_carga"
)

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

----- END FILE: ./app/db.py -----

----- BEGIN FILE: ./app/emailer.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/emailer.py

"""
Servicio de env√≠o de correos v√≠a SMTP (por ejemplo Gmail).
Usa App Password de 16 caracteres (variable de entorno SMTP_PASS).
"""

import os
import ssl
import smtplib
from email.message import EmailMessage

# Configuraci√≥n desde .env
SMTP_HOST = os.getenv("SMTP_HOST", "smtp.gmail.com")   # Servidor SMTP
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))         # Puerto STARTTLS
SMTP_USER = os.getenv("SMTP_USER")                     # Cuenta de correo remitente
SMTP_PASS = os.getenv("SMTP_PASS")                     # App Password
EMAIL_FROM = os.getenv("EMAIL_FROM", SMTP_USER)        # Nombre visible del remitente

def send_email(to_email: str, subject: str, text_body: str, html_body: str | None = None) -> None:
    """
    Env√≠a un correo con versi√≥n texto y opcionalmente HTML.
    Lanza excepci√≥n si falla.
    """

    # 1Ô∏è‚É£ Validar credenciales
    if not SMTP_USER or not SMTP_PASS:
        raise RuntimeError("SMTP_USER/SMTP_PASS no configurados en .env")

    # 2Ô∏è‚É£ Crear el mensaje de correo
    msg = EmailMessage()
    msg["From"] = EMAIL_FROM or SMTP_USER
    msg["To"] = to_email
    msg["Subject"] = subject
    msg.set_content(text_body)
    if html_body:
        msg.add_alternative(html_body, subtype="html")

    # 3Ô∏è‚É£ Conectar al servidor y enviar
    with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as s:
        s.starttls(context=ssl.create_default_context())  # conexi√≥n segura
        s.login(SMTP_USER, SMTP_PASS)                     # autenticaci√≥n
        s.send_message(msg)                               # enviar mensaje

----- END FILE: ./app/emailer.py -----

----- BEGIN FILE: ./app/__init__.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/__init__.py


----- END FILE: ./app/__init__.py -----

----- BEGIN FILE: ./app/main.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/main.py

# app/main.py
"""
Entrypoint principal: inicializa DB, CORS y monta routers.
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.db import Base, engine
from app.routers import users, auth, loads, catalogos  # üëà nuevo router importado

# Inicializar tablas
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Conexi√≥n Carga - Backend",
    openapi_url="/openapi.json",
    swagger_ui_parameters={"persistAuthorization": True},  # recuerda el Bearer en /docs
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
def health():
    return {"ok": True, "message": "API running"}

# Montar routers
app.include_router(users.router)
app.include_router(auth.router)
app.include_router(loads.router)
app.include_router(catalogos.router)  # üëà agregado para municipios, tipo_

----- END FILE: ./app/main.py -----

----- BEGIN FILE: ./app/models.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/models.py

# app/models.py
from sqlalchemy import Column, String, Boolean, DateTime, Integer, ForeignKey, Numeric, func, text, Interval
from sqlalchemy.dialects.postgresql import UUID
from .db import Base
import uuid

class User(Base):
    __tablename__ = "users"
    __table_args__ = {"schema": "conexion_carga"}

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4,
                server_default=text("uuid_generate_v4()"), nullable=False)
    email = Column(String(255), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    first_name = Column(String(120), nullable=False)
    last_name  = Column(String(120), nullable=False)
    phone = Column(String(30), nullable=True)

    is_company = Column(Boolean, nullable=False, server_default=text("false"))
    company_name = Column(String(255), nullable=True)
    is_premium = Column(Boolean, nullable=False, server_default=text("false"))
    active = Column(Boolean, nullable=False, server_default=text("true"))
    created_at = Column(DateTime(timezone=False), nullable=False, server_default=func.now())

    points = Column(Integer, nullable=False, server_default=text("0"))
    referred_by_id = Column(UUID(as_uuid=True),
                            ForeignKey("conexion_carga.users.id", ondelete="SET NULL"),
                            nullable=True)
    referral_rewarded = Column(Boolean, nullable=False, server_default=text("false"))

class Cargo(Base):
    __tablename__ = "carga"
    __table_args__ = {"schema": "conexion_carga"}

    id = Column(UUID(as_uuid=True), primary_key=True, server_default=text("uuid_generate_v4()"))
    empresa_id = Column(UUID(as_uuid=True), nullable=True)

    origen = Column(String, nullable=False)
    destino = Column(String, nullable=False)
    tipo_carga = Column(String, nullable=False)

    peso  = Column(Numeric(10, 2), nullable=False)
    valor = Column(Integer, nullable=False)

    comercial_id = Column(UUID(as_uuid=True),
                          ForeignKey("conexion_carga.users.id", ondelete="CASCADE"),
                          nullable=False)

    comercial = Column(String, nullable=True)
    contacto  = Column(String, nullable=True)
    observaciones = Column(String, nullable=True)

    conductor = Column(String, nullable=True)
    # vehiculo_id = Column(String, nullable=True)  # ‚ùå ELIMINADO
    tipo_vehiculo = Column(String, nullable=True)

    # ‚Üì Fechas eliminadas previamente
    # fecha_salida
    # fecha_llegada_estimada

    estado = Column(String, nullable=False, server_default=text("'publicado'"))
    activo = Column(Boolean, nullable=False, server_default=text("true"))
    premium_trip = Column(Boolean, nullable=False, server_default=text("false"))

    # horas -> interval
    duracion_publicacion = Column(Interval, nullable=True, server_default=text("'24 hours'::interval"))

    created_at = Column(DateTime, nullable=False, server_default=func.now())
    updated_at = Column(DateTime, nullable=False, server_default=func.now())

----- END FILE: ./app/models.py -----

----- BEGIN FILE: ./app/routers/auth.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/routers/auth.py

# app/routers/auth.py
"""
Rutas de autenticaci√≥n.

CAMBIOS CLAVE:
- response_model=TokenOut ahora coincide con el JSON que devolvemos
  (access_token + token_type + user opcional).
- Devolvemos tambi√©n 'user' para que el cliente tenga el perfil inmediatamente
  (evita un /me justo despu√©s de loguear).
- Usamos response_model_exclude_none=True para no forzar 'user' si no lo quieres incluir.
"""

from fastapi import APIRouter, Depends, HTTPException, status, Form
from sqlalchemy.orm import Session

from app.db import get_db
from app import schemas, crud
from app.security import verify_password, create_access_token  # ya existente

router = APIRouter(prefix="/api/auth", tags=["Auth"])


@router.post(
    "/login",
    response_model=schemas.TokenOut,
    response_model_exclude_none=True,
    summary="Login (JSON)",
)
def login_json(payload: schemas.LoginIn, db: Session = Depends(get_db)):
    """
    Inicia sesi√≥n con JSON:
      { "email": "...", "password": "..." }

    Respuesta (coincide con schemas.TokenOut):
      {
        "access_token": "<JWT>",
        "token_type": "bearer",
        "user": { ...UserOut }   # opcional pero recomendado
      }
    """
    user = crud.get_user_by_email(db, payload.email)
    if not user or not verify_password(payload.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inv√°lidas.",
        )

    token = create_access_token({"sub": str(user.id)})

    # Construimos UserOut para no filtrar campos sensibles y mantener
    # el contrato estable entre back y front.
    user_out = schemas.UserOut.model_validate(user)

    return {
        "access_token": token,
        "token_type": "bearer",
        "user": user_out,
    }


@router.post(
    "/login-form",
    response_model=schemas.TokenOut,
    response_model_exclude_none=True,
    summary="Login (form-url-encoded)",
)
def login_form(
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db),
):
    """
    Variante para facilitar pruebas desde Swagger o formularios
    application/x-www-form-urlencoded.
    """
    user = crud.get_user_by_email(db, email)
    if not user or not verify_password(password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales inv√°lidas.",
        )

    token = create_access_token({"sub": str(user.id)})
    user_out = schemas.UserOut.model_validate(user)

    return {
        "access_token": token,
        "token_type": "bearer",
        "user": user_out,
    }

----- END FILE: ./app/routers/auth.py -----

----- BEGIN FILE: ./app/routers/catalogos.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/routers/catalogos.py

# app/routers/catalogos.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from sqlalchemy import text
from typing import List
from app.db import get_db

router = APIRouter(prefix="/api/catalogos", tags=["Cat√°logos"])

# Utilidad: limpiar nombre
def _norm(s: str) -> str:
    return (s or "").strip()

@router.get("/municipios", response_model=List[str])
def lista_municipios(
    limit: int = Query(10000, ge=1, le=50000),
    db: Session = Depends(get_db),
):
    # Solo necesitamos nombres. Filtramos por activo si existe esa columna.
    sql = text("""
        SELECT nombre
        FROM municipio
        WHERE (activo IS NULL OR activo = TRUE)
        ORDER BY nombre ASC
        LIMIT :limit
    """)
    rows = db.execute(sql, {"limit": limit}).fetchall()
    return [r[0] for r in rows if r[0]]

@router.get("/tipos-carga", response_model=List[str])
def lista_tipos_carga(
    limit: int = Query(10000, ge=1, le=50000),
    db: Session = Depends(get_db),
):
    # Tabla: tipo_carga (columna 'nombre' y opcional 'activo')
    sql = text("""
        SELECT nombre
        FROM tipo_carga
        WHERE (activo IS NULL OR activo = TRUE)
        ORDER BY nombre ASC
        LIMIT :limit
    """)
    rows = db.execute(sql, {"limit": limit}).fetchall()
    return [r[0] for r in rows if r[0]]

@router.get("/tipos-vehiculo", response_model=List[str])
def lista_tipos_vehiculo(
    limit: int = Query(10000, ge=1, le=50000),
    db: Session = Depends(get_db),
):
    # Tabla: tipo_vehiculo (columna 'nombre' y opcional 'activo')
    sql = text("""
        SELECT nombre
        FROM tipo_vehiculo
        WHERE (activo IS NULL OR activo = TRUE)
        ORDER BY nombre ASC
        LIMIT :limit
    """)
    rows = db.execute(sql, {"limit": limit}).fetchall()
    return [r[0] for r in rows if r[0]]

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Altas "silenciosas": si el usuario escribe uno que no existe
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

@router.post("/tipos-carga", status_code=201)
def crear_tipo_carga(nombre: str, db: Session = Depends(get_db)):
    nombre = _norm(nombre)
    if not nombre:
        raise HTTPException(status_code=400, detail="Nombre requerido")
    # upsert simple por nombre
    sql_exists = text("SELECT 1 FROM tipo_carga WHERE LOWER(nombre)=LOWER(:n) LIMIT 1")
    if db.execute(sql_exists, {"n": nombre}).fetchone():
        return {"created": False, "nombre": nombre}  # ya exist√≠a
    sql_ins = text("INSERT INTO tipo_carga (nombre, activo) VALUES (:n, TRUE)")
    db.execute(sql_ins, {"n": nombre})
    db.commit()
    return {"created": True, "nombre": nombre}

@router.post("/tipos-vehiculo", status_code=201)
def crear_tipo_vehiculo(nombre: str, db: Session = Depends(get_db)):
    nombre = _norm(nombre)
    if not nombre:
        raise HTTPException(status_code=400, detail="Nombre requerido")
    sql_exists = text("SELECT 1 FROM tipo_vehiculo WHERE LOWER(nombre)=LOWER(:n) LIMIT 1")
    if db.execute(sql_exists, {"n": nombre}).fetchone():
        return {"created": False, "nombre": nombre}
    sql_ins = text("INSERT INTO tipo_vehiculo (nombre, activo) VALUES (:n, TRUE)")
    db.execute(sql_ins, {"n": nombre})
    db.commit()
    return {"created": True, "nombre": nombre}

----- END FILE: ./app/routers/catalogos.py -----

----- BEGIN FILE: ./app/routers/loads.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/routers/loads.py

# app/routers/loads.py
from fastapi import APIRouter, Depends, status, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List

from app.db import get_db
from app.security import get_current_user
from app import crud, schemas, models

router = APIRouter(prefix="/api/loads", tags=["Loads"])

@router.post("", response_model=schemas.CargoOut, status_code=status.HTTP_201_CREATED)
def create_load(payload: schemas.CargoCreate,
                db: Session = Depends(get_db),
                current: models.User = Depends(get_current_user)):
    return crud.create_cargo(db, payload, comercial_id=current.id)

@router.get("/public", response_model=List[schemas.CargoOut])
def list_public(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_public_cargas(db, skip=skip, limit=limit)

@router.get("/mine", response_model=List[schemas.CargoOut])
def list_my_loads(status: str = Query("all", pattern="^(all|published|expired)$"),
                  skip: int = 0, limit: int = 100,
                  db: Session = Depends(get_db),
                  current: models.User = Depends(get_current_user)):
    return crud.get_my_cargas(db, current.id, status=status, skip=skip, limit=limit)

@router.get("/{load_id}", response_model=schemas.CargoOut)
def get_one(load_id: str, db: Session = Depends(get_db)):
    obj = crud.get_cargo(db, load_id)
    if not obj:
        raise HTTPException(status_code=404, detail="Viaje no encontrado.")
    return obj

@router.post("/{load_id}/expire", response_model=schemas.CargoOut)
def expire(load_id: str,
           db: Session = Depends(get_db),
           current: models.User = Depends(get_current_user)):
    obj = crud.expire_cargo(db, load_id, owner_id=current.id)
    if not obj:
        raise HTTPException(status_code=404, detail="No encontrado o sin permisos.")
    return obj

----- END FILE: ./app/routers/loads.py -----

----- BEGIN FILE: ./app/routers/users.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/routers/users.py

# app/routers/users.py
"""
M√≥dulo de rutas de usuarios.
Contiene:
- registro
- verificaci√≥n de email
- actualizaci√≥n
- /me (perfil del usuario con token)
"""
from __future__ import annotations
import os, time, random, string
from typing import Dict
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from sqlalchemy.orm import Session

from app import crud, schemas, models  # ‚¨ÖÔ∏è (a√±adido: models para buscar referidor por id)
from app.db import get_db
from app.security import get_password_hash, get_current_user
from app.services.emailer import send_email

# === Config ===
EMAIL_CODE_LENGTH = int(os.getenv("EMAIL_CODE_LENGTH", "6"))
EMAIL_CODE_TTL_MINUTES = int(os.getenv("EMAIL_CODE_TTL_MINUTES", "5"))
EMAIL_RESEND_COOLDOWN_SECONDS = int(os.getenv("EMAIL_RESEND_COOLDOWN_SECONDS", "45"))

# === Stores in-memory (demo) ===
_verif_store: Dict[str, dict] = {}
_last_send_epoch: Dict[str, float] = {}

def _gen_code(n: int) -> str:
    return "".join(random.choices(string.digits, k=n))

router = APIRouter(prefix="/api/users", tags=["Users"])

# ==== Modelos internos ====
class VerifyIn(BaseModel):
    email: EmailStr
    code: str = Field(min_length=1, max_length=64)

@router.get("", response_model=list[schemas.UserOut])
def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    return crud.get_users(db, skip=skip, limit=limit)

@router.post("/register", response_model=schemas.UserOut, status_code=status.HTTP_201_CREATED)
def register_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # email duplicado
    existing = crud.get_user_by_email(db, user.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    # validar contrase√±as iguales
    if user.password != user.confirm_password:
        raise HTTPException(status_code=400, detail="Passwords do not match")

    # resolver referidor (OPCIONAL) -> referrer_email viene en schemas.UserCreate
    ref_id = None
    if user.referrer_email:
        ref = crud.get_user_by_email(db, str(user.referrer_email))
        if not ref:
            raise HTTPException(status_code=400, detail="Referrer email does not exist")
        ref_id = ref.id  # UUID del referidor

    # crear usuario con hash y referidor
    pw_hash = get_password_hash(user.password)
    created = crud.create_user(db, user, pw_hash, referred_by_id=ref_id)  # ‚¨ÖÔ∏è pasamos ref_id
    created.active = False
    db.add(created); db.commit(); db.refresh(created)

    # cooldown para reenv√≠o de c√≥digo
    now = time.time()
    last = _last_send_epoch.get(user.email, 0.0)
    if now - last < EMAIL_RESEND_COOLDOWN_SECONDS:
        raise HTTPException(status_code=429, detail="Wait before resending the code")

    # generar c√≥digo y enviar email
    code = _gen_code(EMAIL_CODE_LENGTH)
    subject = "Verification code - Conexi√≥n Carga"
    text = f"Hola,\nTu c√≥digo de verificaci√≥n es: {code}\nVence en {EMAIL_CODE_TTL_MINUTES} minutos."
    html = f"""
        <p>Hola,</p>
        <p>Tu c√≥digo de verificaci√≥n es:
           <strong style='font-size:20px;letter-spacing:2px'>{code}</strong></p>
        <p>Vence en <strong>{EMAIL_CODE_TTL_MINUTES}</strong> minutos.</p>
        <p style='color:#666;font-size:12px'>Si no solicitaste este c√≥digo, ignora este correo.</p>
    """
    try:
        send_email(user.email, subject, text, html)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Email send failed: {e}")

    _verif_store[user.email] = {
        "code": code,
        "expires": time.time() + (EMAIL_CODE_TTL_MINUTES * 60),
        "attempts": 0,
    }
    _last_send_epoch[user.email] = now
    return created

@router.post("/verify")
def verify_email(payload: VerifyIn, db: Session = Depends(get_db)):
    rec = _verif_store.get(payload.email)
    if not rec:
        raise HTTPException(status_code=400, detail="No verification pending for this email")

    if time.time() > rec["expires"]:
        _verif_store.pop(payload.email, None)
        raise HTTPException(status_code=400, detail="Code expired")

    if str(payload.code).strip() != str(rec["code"]):
        rec["attempts"] = rec.get("attempts", 0) + 1
        if rec["attempts"] >= 5:
            _verif_store.pop(payload.email, None)
            raise HTTPException(status_code=400, detail="Too many invalid attempts")
        raise HTTPException(status_code=400, detail="Invalid code")

    user = crud.get_user_by_email(db, payload.email)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    was_active = bool(user.active)
    user.active = True

    # ‚¨áÔ∏è premiar referidor UNA vez (cuando el usuario se activa por primera vez)
    if not was_active and user.referred_by_id and not getattr(user, "referral_rewarded", False):
        # buscar referidor por UUID
        ref = db.query(models.User).get(user.referred_by_id)
        if ref:
            ref.points = int(ref.points or 0) + 1
            user.referral_rewarded = True

    db.add(user); db.commit(); db.refresh(user)

    _verif_store.pop(payload.email, None)
    return {"status": "ok", "message": "Email verified. User activated.", "user_id": str(user.id)}

@router.get("/me", response_model=schemas.UserOut)
def get_me(current: schemas.UserOut = Depends(get_current_user)):
    """Devuelve el perfil del usuario autenticado (token en Authorization: Bearer)."""
    return current

@router.put("/{user_id}", response_model=schemas.UserOut)
def update_user(user_id: UUID, user: schemas.UserUpdate, db: Session = Depends(get_db)):
    if user.email:
        existing = crud.get_user_by_email(db, user.email)
        if existing and existing.id != user_id:
            raise HTTPException(status_code=400, detail="Email already in use")
    updated = crud.update_user(db, user_id, user)
    if not updated:
        raise HTTPException(status_code=404, detail="User not found")
    return updated

----- END FILE: ./app/routers/users.py -----

----- BEGIN FILE: ./app/schemas.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/schemas.py

# app/schemas.py
from __future__ import annotations
from typing import Optional
from pydantic import BaseModel, EmailStr, Field
from uuid import UUID
from datetime import datetime

# ========= USERS =========

class UserBase(BaseModel):
    email: EmailStr
    first_name: str = Field(min_length=1)
    last_name: str = Field(min_length=1)
    phone: Optional[str] = None
    is_company: bool = False
    company_name: Optional[str] = None

class UserCreate(UserBase):
    password: str = Field(min_length=8)
    confirm_password: str
    referrer_email: Optional[EmailStr] = None

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    phone: Optional[str] = None
    is_company: Optional[bool] = None
    company_name: Optional[str] = None
    password: Optional[str] = None

class UserOut(UserBase):
    id: UUID
    active: bool
    points: int = 0
    is_premium: bool = False

    class Config:
        from_attributes = True

# ========= AUTH =========
class LoginIn(BaseModel):
    email: EmailStr
    password: str

class TokenOut(BaseModel):
    access_token: str
    token_type: str = "bearer"
    user: Optional[UserOut] = None

# ========= CARGA =========
class CargoBase(BaseModel):
    empresa_id: Optional[UUID] = None
    origen: str
    destino: str
    tipo_carga: str
    peso: float
    valor: int
    # extras
    comercial: Optional[str] = None
    contacto: Optional[str] = None
    observaciones: Optional[str] = None
    conductor: Optional[str] = None
    # vehiculo_id: Optional[str] = None  # ‚ùå ELIMINADO
    tipo_vehiculo: Optional[str] = None

    # duraci√≥n en horas
    duration_hours: int = Field(default=24, ge=1, le=168)

class CargoCreate(CargoBase):
    pass

class CargoOut(CargoBase):
    id: UUID
    comercial_id: UUID
    estado: str
    activo: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class CatalogoIn(BaseModel):
    nombre: str

class CatalogoOut(BaseModel):
    id: int
    nombre: str
    activo: bool

    class Config:
        from_attributes = True

----- END FILE: ./app/schemas.py -----

----- BEGIN FILE: ./app/security.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/security.py

# app/security.py
from __future__ import annotations
from datetime import datetime, timedelta, timezone
from typing import Optional
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from passlib.context import CryptContext
from sqlalchemy.orm import Session

from app.db import get_db
from app import crud, models

# =========================
# Config JWT
# =========================
SECRET_KEY = "super-secret-key-change-me"        # <-- c√°mbiala en producci√≥n
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 12            # 12h

# =========================
# Password hashing
# =========================
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, password_hash: str) -> bool:
    try:
        return pwd_context.verify(plain_password, password_hash)
    except Exception:
        return False

# =========================
# Token helpers
# =========================
def create_access_token(data: dict, expires_minutes: int = ACCESS_TOKEN_EXPIRE_MINUTES) -> str:
    to_encode = data.copy()
    expire = datetime.now(tz=timezone.utc) + timedelta(minutes=expires_minutes)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")  # usado por Swagger s√≥lo si usas /login-form

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> models.User:
    """Lee el token Bearer, decodifica y recupera el usuario de BD."""
    credentials_exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Not authenticated",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        sub = payload.get("sub")
        if not sub:
            raise credentials_exc
        user_id = UUID(str(sub))
    except JWTError:
        raise credentials_exc

    user = crud.get_user(db, user_id)
    if not user:
        raise credentials_exc
    return user

----- END FILE: ./app/security.py -----

----- BEGIN FILE: ./app/services/emailer.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/services/emailer.py

# app/services/emailer.py
import os
import ssl
import smtplib
from email.message import EmailMessage

SMTP_HOST = os.getenv("SMTP_HOST", "smtp.gmail.com")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER = os.getenv("SMTP_USER")
SMTP_PASS = os.getenv("SMTP_PASS")
EMAIL_FROM = os.getenv("EMAIL_FROM", SMTP_USER)

def send_email(to_email: str, subject: str, text_body: str, html_body: str | None = None) -> None:
    if not SMTP_USER or not SMTP_PASS:
        raise RuntimeError("SMTP_USER/SMTP_PASS no configurados en .env")

    msg = EmailMessage()
    msg["From"] = EMAIL_FROM or SMTP_USER
    msg["To"] = to_email
    msg["Subject"] = subject
    msg.set_content(text_body)
    if html_body:
        msg.add_alternative(html_body, subtype="html")

    with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as s:
        s.starttls(context=ssl.create_default_context())
        s.login(SMTP_USER, SMTP_PASS)
        s.send_message(msg)

----- END FILE: ./app/services/emailer.py -----

----- BEGIN FILE: ./app/services/__init__.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/app/services/__init__.py


----- END FILE: ./app/services/__init__.py -----

----- BEGIN FILE: ./backups/security_2025-10-21_155406.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/backups/security_2025-10-21_155406.py

from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)
# app/security.py
"""
Utilidades de seguridad:
- Hash/verify de contrase√±as (bcrypt)
- Creaci√≥n y verificaci√≥n de JWT (HS256)
- Dependencia `get_current_user` para rutas protegidas
"""
from __future__ import annotations

import os
from datetime import datetime, timedelta
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from passlib.context import CryptContext
from sqlalchemy.orm import Session

from app.db import get_db
from app import crud, schemas

# === Config de JWT ===
JWT_SECRET = os.getenv("JWT_SECRET", "change_me_please")
JWT_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))
ALGORITHM = "HS256"

# === Password hashing (bcrypt) ===
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    """Genera hash seguro para almacenar en DB."""
    return pwd_context.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    """Compara contrase√±a en texto con su hash."""
    return pwd_context.verify(plain, hashed)

# === OAuth bearer (lee "Authorization: Bearer <token>") ===
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/auth/login")  # solo para el flow de docs

def create_access_token(data: dict, expires_minutes: Optional[int] = None) -> str:
    """Crea un JWT firmando `data` con expiraci√≥n."""
    to_encode = data.copy()
    exp = datetime.utcnow() + timedelta(minutes=expires_minutes or JWT_EXPIRE_MINUTES)
    to_encode.update({"exp": exp})
    return jwt.encode(to_encode, JWT_SECRET, algorithm=ALGORITHM)

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db),
) -> schemas.UserOut:
    """Decodifica el token y devuelve el usuario actual (400/401 si algo falla)."""
    cred_exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[ALGORITHM])
        email: Optional[str] = payload.get("sub")
        if not email:
            raise cred_exc
    except JWTError:
        raise cred_exc

    user = crud.get_user_by_email(db, email)
    if not user:
        raise cred_exc
    if not user.active:
        raise HTTPException(status_code=403, detail="User is not active")

    # devolvemos el esquema limpio
    return schemas.UserOut.model_validate(user, from_attributes=True)

----- END FILE: ./backups/security_2025-10-21_155406.py -----

----- BEGIN FILE: ./backups/security_2025-10-21_160647.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/backups/security_2025-10-21_160647.py

# app/security.py
# ============================================================
# Utilidades de seguridad:
# - Hash y verificaci√≥n de contrase√±as (passlib/bcrypt)
# - Creaci√≥n de tokens JWT
# ============================================================

from __future__ import annotations  # <= Debe ir PRIMERO en el archivo

import os
from datetime import datetime, timedelta, timezone
from typing import Any, Dict

from jose import jwt
from passlib.context import CryptContext

# ------------------------------------------------------------
# Config
# ------------------------------------------------------------
JWT_SECRET = os.getenv("JWT_SECRET", "change_me_please")
JWT_ALG = os.getenv("JWT_ALGORITHM", "HS256")
JWT_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))

# Contexto de passlib para bcrypt
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ------------------------------------------------------------
# Contrase√±as
# ------------------------------------------------------------
def get_password_hash(password: str) -> str:
    """Devuelve el hash seguro de la contrase√±a."""
    return pwd_context.hash(password)

def verify_password(plain_password: str, password_hash: str) -> bool:
    """Compara contrase√±a en texto plano vs. hash almacenado."""
    return pwd_context.verify(plain_password, password_hash)

# ------------------------------------------------------------
# JWT
# ------------------------------------------------------------
def create_access_token(
    subject: str | int,
    expires_minutes: int | None = None,
    extra_claims: Dict[str, Any] | None = None,
) -> str:
    """
    Crea un JWT de acceso.
    - subject: normalmente el ID del usuario
    - expires_minutes: por defecto toma JWT_EXPIRE_MINUTES
    - extra_claims: claims adicionales que quieras meter al token
    """
    if expires_minutes is None:
        expires_minutes = JWT_EXPIRE_MINUTES

    now = datetime.now(timezone.utc)
    exp = now + timedelta(minutes=expires_minutes)

    payload: Dict[str, Any] = {
        "sub": str(subject),
        "iat": int(now.timestamp()),
        "exp": int(exp.timestamp()),
    }

    if extra_claims:
        payload.update(extra_claims)

    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)
    return token

----- END FILE: ./backups/security_2025-10-21_160647.py -----

----- BEGIN FILE: ./backups/security_2025-10-21_160708.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/backups/security_2025-10-21_160708.py

# app/security.py
# ============================================================
# Utilidades de seguridad:
# - Hash y verificaci√≥n de contrase√±as (passlib/bcrypt)
# - Creaci√≥n/decodificaci√≥n de JWT
# - Dependencia FastAPI: get_current_user
# ============================================================

from __future__ import annotations  # üëà Debe ser la PRIMERA l√≠nea real

import os
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional

from jose import jwt, JWTError
from passlib.context import CryptContext

# Para la dependencia get_current_user
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

# ------------------------------------------------------------
# Config
# ------------------------------------------------------------
JWT_SECRET = os.getenv("JWT_SECRET", "change_me_please")
JWT_ALG = os.getenv("JWT_ALGORITHM", "HS256")
JWT_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))

# OAuth2 password flow (solo para que Swagger sepa el endpoint de login)
# No afecta al funcionamiento real del decode.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")

# Contexto de passlib para bcrypt
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# ------------------------------------------------------------
# Contrase√±as
# ------------------------------------------------------------
def get_password_hash(password: str) -> str:
    """Devuelve el hash seguro de la contrase√±a."""
    return pwd_context.hash(password)


def verify_password(plain_password: str, password_hash: str) -> bool:
    """Compara contrase√±a en texto plano vs. hash almacenado."""
    return pwd_context.verify(plain_password, password_hash)


# ------------------------------------------------------------
# JWT
# ------------------------------------------------------------
def create_access_token(
    subject: str | int,
    expires_minutes: Optional[int] = None,
    extra_claims: Optional[Dict[str, Any]] = None,
) -> str:
    """
    Crea un JWT de acceso.
    - subject: normalmente el ID del usuario
    - expires_minutes: por defecto toma JWT_EXPIRE_MINUTES
    - extra_claims: claims adicionales que quieras meter al token
    """
    if expires_minutes is None:
        expires_minutes = JWT_EXPIRE_MINUTES

    now = datetime.now(timezone.utc)
    exp = now + timedelta(minutes=expires_minutes)

    payload: Dict[str, Any] = {
        "sub": str(subject),
        "iat": int(now.timestamp()),
        "exp": int(exp.timestamp()),
    }
    if extra_claims:
        payload.update(extra_claims)

    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)
    return token


def decode_token(token: str) -> Dict[str, Any]:
    """Decodifica el JWT y devuelve el payload o lanza HTTP 401/403."""
    credentials_exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALG])
    except JWTError:
        raise credentials_exc
    if not isinstance(payload, dict) or "sub" not in payload:
        raise credentials_exc
    return payload


# ------------------------------------------------------------
# Dependencia: usuario autenticado desde el token
# ------------------------------------------------------------
def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(lambda: __import__("app.db", fromlist=["get_db"]).db.get_db().__next__()),
):
    """
    Devuelve el usuario autenticado a partir del token Bearer.
    Importamos `get_db` y `crud` de forma perezosa para evitar ciclos.
    """
    # Decodificar token
    payload = decode_token(token)
    user_id = payload.get("sub")
    if user_id is None:
        raise HTTPException(status_code=401, detail="Invalid token: missing subject")

    # Import lazy para evitar ciclos
    crud = __import__("app.crud", fromlist=["get_user"])  # type: ignore

    # Traer user por ID (UUID en tu modelo). Aceptamos str/int.
    try:
        from uuid import UUID
        uid = UUID(str(user_id))
    except Exception:
        # Si tu clave primaria no es UUID, elimina este bloque y usa str(user_id).
        uid = user_id  # type: ignore

    user = crud.get_user(db, uid)  # type: ignore
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return user

----- END FILE: ./backups/security_2025-10-21_160708.py -----

----- BEGIN FILE: ./backups/security_2025-10-21_161715.py -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/backups/security_2025-10-21_161715.py

# app/security.py
# ============================================================
# Utilidades de seguridad:
# - Hash y verificaci√≥n de contrase√±as (passlib/bcrypt)
# - Creaci√≥n/decodificaci√≥n de JWT
# - Dependencia FastAPI: get_current_user
# ============================================================

from __future__ import annotations  # üëà Debe ser la PRIMERA l√≠nea real

import os
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional

from jose import jwt, JWTError
from passlib.context import CryptContext

# Para la dependencia get_current_user
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

# ------------------------------------------------------------
# Config
# ------------------------------------------------------------
JWT_SECRET = os.getenv("JWT_SECRET", "change_me_please")
JWT_ALG = os.getenv("JWT_ALGORITHM", "HS256")
JWT_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "60"))

# OAuth2 password flow (solo para que Swagger sepa el endpoint de login)
# No afecta al funcionamiento real del decode.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")

# Contexto de passlib para bcrypt
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# ------------------------------------------------------------
# Contrase√±as
# ------------------------------------------------------------
def get_password_hash(password: str) -> str:
    """Devuelve el hash seguro de la contrase√±a."""
    return pwd_context.hash(password)


def verify_password(plain_password: str, password_hash: str) -> bool:
    """Compara contrase√±a en texto plano vs. hash almacenado."""
    return pwd_context.verify(plain_password, password_hash)


# ------------------------------------------------------------
# JWT
# ------------------------------------------------------------
def create_access_token(
    subject: str | int,
    expires_minutes: Optional[int] = None,
    extra_claims: Optional[Dict[str, Any]] = None,
) -> str:
    """
    Crea un JWT de acceso.
    - subject: normalmente el ID del usuario
    - expires_minutes: por defecto toma JWT_EXPIRE_MINUTES
    - extra_claims: claims adicionales que quieras meter al token
    """
    if expires_minutes is None:
        expires_minutes = JWT_EXPIRE_MINUTES

    now = datetime.now(timezone.utc)
    exp = now + timedelta(minutes=expires_minutes)

    payload: Dict[str, Any] = {
        "sub": str(subject),
        "iat": int(now.timestamp()),
        "exp": int(exp.timestamp()),
    }
    if extra_claims:
        payload.update(extra_claims)

    token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)
    return token


def decode_token(token: str) -> Dict[str, Any]:
    """Decodifica el JWT y devuelve el payload o lanza HTTP 401/403."""
    credentials_exc = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALG])
    except JWTError:
        raise credentials_exc
    if not isinstance(payload, dict) or "sub" not in payload:
        raise credentials_exc
    return payload


# ------------------------------------------------------------
# Dependencia: usuario autenticado desde el token
# ------------------------------------------------------------
def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(lambda: __import__("app.db", fromlist=["get_db"]).db.get_db().__next__()),
):
    """
    Devuelve el usuario autenticado a partir del token Bearer.
    Importamos `get_db` y `crud` de forma perezosa para evitar ciclos.
    """
    # Decodificar token
    payload = decode_token(token)
    user_id = payload.get("sub")
    if user_id is None:
        raise HTTPException(status_code=401, detail="Invalid token: missing subject")

    # Import lazy para evitar ciclos
    crud = __import__("app.crud", fromlist=["get_user"])  # type: ignore

    # Traer user por ID (UUID en tu modelo). Aceptamos str/int.
    try:
        from uuid import UUID
        uid = UUID(str(user_id))
    except Exception:
        # Si tu clave primaria no es UUID, elimina este bloque y usa str(user_id).
        uid = user_id  # type: ignore

    user = crud.get_user(db, uid)  # type: ignore
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return user

----- END FILE: ./backups/security_2025-10-21_161715.py -----

----- BEGIN FILE: ./db_schema_all.sql -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/db_schema_all.sql


----- END FILE: ./db_schema_all.sql -----

----- BEGIN FILE: ./dump_app.sh -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/dump_app.sh

#!/usr/bin/env bash
set -euo pipefail
sudo apt-get update && sudo apt-get install -y tree >/dev/null 2>&1 || true
{
  echo "# Snapshot: $(date -Iseconds)"
  echo "## √Årbol"; tree -a app -I '__pycache__|*.pyc|.git|backups'
  echo; echo "## requirements.txt"; [ -f requirements.txt ] && sed 's/^/    /' requirements.txt || echo "    (no existe)"
  echo; echo "## .py files"
  find app -type f -name '*.py' -not -path '*/__pycache__/*' -print0 | sort -z | while IFS= read -r -d '' f; do
    echo "-----8<----- FILE: $f -----"; nl -ba "$f"; echo "-----8<----- END FILE: $f -----"
  done
} > app_completa.txt
echo "Generado app_completa.txt"

----- END FILE: ./dump_app.sh -----

----- BEGIN FILE: ./requirements.txt -----
ABSOLUTE PATH: /opt/apps/conexion_carga_back/requirements.txt

fastapi>=0.110,<1
uvicorn[standard]>=0.23
SQLAlchemy>=2.0
psycopg2-binary>=2.9
python-dotenv>=1.0
passlib[bcrypt]==1.7.4
bcrypt==4.0.1
pydantic>=2,<3

----- END FILE: ./requirements.txt -----

