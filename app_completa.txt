===== app/routers/users.py =====
"""
Users router: Registro de usuario + envío de código de verificación por email.

Flujo:
1) Valida JSON contra schemas.UserCreate (contraseñas iguales, lógica company_name).
2) Checa duplicado de email (409 si existe).
3) Hashea password y crea el usuario (crud.create_user).
4) Controla cooldown para evitar spam de correos.
5) Genera código numérico y lo envía por email (texto + HTML).
6) Devuelve respuesta (incluye 'code' SOLO para pruebas; en producción, quítalo).

Requiere:
- app/db.py con get_db (Session)
- app/crud.py (get_user_by_email, create_user)
- app/security.py con get_password_hash
- app/services/emailer.py con send_email
"""

from __future__ import annotations

import os
import time
import random
import string
from typing import Dict

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.db import get_db
from app import crud, schemas
from app.security import get_password_hash
from app.services.emailer import send_email

# Parámetros desde .env (con defaults)
EMAIL_CODE_LENGTH = int(os.getenv("EMAIL_CODE_LENGTH", "6"))
EMAIL_CODE_TTL_MINUTES = int(os.getenv("EMAIL_CODE_TTL_MINUTES", "15"))
EMAIL_RESEND_COOLDOWN_SECONDS = int(os.getenv("EMAIL_RESEND_COOLDOWN_SECONDS", "45"))

# Memoria simple para cooldown por email (en producción: DB/Redis)
_last_send_epoch: Dict[str, float] = {}

router = APIRouter(prefix="/api/users", tags=["users"])


def _gen_code(n: int) -> str:
    """Genera un código numérico de n dígitos (p. ej. '123456')."""
    return "".join(random.choices(string.digits, k=n))


@router.post("/register", summary="Register User")
def register_user(payload: schemas.UserCreate, db: Session = Depends(get_db)):
    # 0) Evitar duplicados
    if crud.get_user_by_email(db, payload.email):
        raise HTTPException(status_code=409, detail="Email already registered")

    # 1) Hash de la contraseña
    password_hash = get_password_hash(payload.password)

    # 2) Crear usuario (crud ya normaliza company_name si is_company=False)
    user = crud.create_user(db, payload, password_hash)

    # 3) Anti-spam: cooldown por email
    now = time.time()
    last = _last_send_epoch.get(payload.email, 0.0)
    if now - last < EMAIL_RESEND_COOLDOWN_SECONDS:
        raise HTTPException(status_code=429, detail="Wait before resending the code")

    # 4) Generar código
    code = _gen_code(EMAIL_CODE_LENGTH)

    # 5) Enviar email
    subject = "Verification code - Conexión Carga"
    text = (
        f"Your verification code is: {code}\n"
        f"It expires in {EMAIL_CODE_TTL_MINUTES} minutes.\n\n"
        f"If you didn't request this code, please ignore this email."
    )
    html = f"""
    <p>Your verification code is:
       <strong style="font-size:20px;letter-spacing:2px">{code}</strong></p>
    <p>It expires in <strong>{EMAIL_CODE_TTL_MINUTES}</strong> minutes.</p>
    <p style="color:#666;font-size:12px">If you didn't request this code, please ignore this email.</p>
    """
    try:
        send_email(payload.email, subject, text, html)
    except Exception as e:
        # Política simple: si falla el envío, devolvemos 500; el usuario ya quedó creado.
        # Puedes cambiar a "estado pendiente" y reintentar luego.
        raise HTTPException(status_code=500, detail=f"Email send failed: {e}")

    _last_send_epoch[payload.email] = now

    # 6) Respuesta: devolvemos el 'code' SOLO para pruebas; quítalo en prod.
    return {
        "status": "ok",
        "user_id": str(user.id),
        "email": user.email,
        "is_company": user.is_company,
        "company_name": user.company_name,  # será None si is_company=False
        "message": "Verification code sent to email",
        "code": code,  # ⚠️ quitar en producción
    }
===== app/main.py =====
# app/main.py
"""
Entrypoint principal de la API "Conexión Carga".
Aquí se definen los endpoints y la lógica de verificación por correo.
"""

# ---------------------------------------------------------------------
# 🔹 Importaciones básicas
# ---------------------------------------------------------------------
from __future__ import annotations     # Permite usar anotaciones de tipo adelantadas
from uuid import UUID
import os, time, random, string
from typing import Dict

# ---------------------------------------------------------------------
# 🔹 Dependencias de FastAPI
# ---------------------------------------------------------------------
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, Field
from sqlalchemy.orm import Session

# ---------------------------------------------------------------------
# 🔹 Importa tus módulos internos
# ---------------------------------------------------------------------
from . import crud, schemas, models
from .db import Base, engine, get_db
from .security import get_password_hash
from app.services.emailer import send_email  # Servicio SMTP

# ---------------------------------------------------------------------
# 🔹 Configuración desde variables de entorno (.env)
# ---------------------------------------------------------------------
EMAIL_CODE_LENGTH = int(os.getenv("EMAIL_CODE_LENGTH", "6"))           # longitud del código
EMAIL_CODE_TTL_MINUTES = int(os.getenv("EMAIL_CODE_TTL_MINUTES", "15"))# tiempo de validez (min)
EMAIL_RESEND_COOLDOWN_SECONDS = int(os.getenv("EMAIL_RESEND_COOLDOWN_SECONDS", "45"))  # espera entre reenvíos

# ---------------------------------------------------------------------
# 🔹 Estructuras en memoria (solo para demo)
#    En producción podrías usar Redis o base de datos
# ---------------------------------------------------------------------
# Ejemplo de estructura:
# {
#   "user@example.com": { "code": "123456", "expires": 1720000000.0, "attempts": 0 }
# }
_verif_store: Dict[str, dict] = {}

# Control para evitar reenvíos de código muy seguidos
_last_send_epoch: Dict[str, float] = {}

# ---------------------------------------------------------------------
# 🔹 Función auxiliar para generar código aleatorio
# ---------------------------------------------------------------------
def _gen_code(n: int) -> str:
    """Genera un código numérico aleatorio de n dígitos."""
    return "".join(random.choices(string.digits, k=n))

# ---------------------------------------------------------------------
# 🔹 Inicializa DB y app
# ---------------------------------------------------------------------
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Conexión Carga - Backend", openapi_url="/openapi.json")

# Permitir CORS (útil si el frontend está en otro dominio)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Cambia esto en producción por tus dominios permitidos
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ---------------------------------------------------------------------
# 🔹 Health check (para saber si el backend está vivo)
# ---------------------------------------------------------------------
@app.get("/health")
def health():
    return {"ok": True}

# ---------------------------------------------------------------------
# 🔹 Endpoint: Listar usuarios
# ---------------------------------------------------------------------
@app.get("/api/users", response_model=list[schemas.UserOut])
def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """
    Lista todos los usuarios. Útil para verificar el campo 'active' durante pruebas.
    """
    return crud.get_users(db, skip=skip, limit=limit)

# ---------------------------------------------------------------------
# 🔹 Endpoint: Registro de usuario
# ---------------------------------------------------------------------
@app.post("/api/users/register", response_model=schemas.UserOut, status_code=status.HTTP_201_CREATED)
def register_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    """
    Registra un nuevo usuario y envía un código de verificación por correo.
    """

    # 1️⃣ Validar que el correo no esté ya registrado
    existing = crud.get_user_by_email(db, user.email)
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    # 2️⃣ Crear usuario con contraseña hasheada
    pw_hash = get_password_hash(user.password)
    created = crud.create_user(db, user, pw_hash)

    # 3️⃣ Marcar el usuario como inactivo hasta verificar
    created.active = False
    db.add(created)
    db.commit()
    db.refresh(created)

    # 4️⃣ Prevenir abusos de reenvío de código
    now = time.time()
    last = _last_send_epoch.get(user.email, 0.0)
    if now - last < EMAIL_RESEND_COOLDOWN_SECONDS:
        raise HTTPException(status_code=429, detail="Wait before resending the code")

    # 5️⃣ Generar código y enviar correo
    code = _gen_code(EMAIL_CODE_LENGTH)
    subject = "Verification code - Conexión Carga"
    text = f"Hola,\nTu código de verificación es: {code}\nVence en {EMAIL_CODE_TTL_MINUTES} minutos."
    html = f"""
        <p>Hola,</p>
        <p>Tu código de verificación es:
           <strong style='font-size:20px;letter-spacing:2px'>{code}</strong></p>
        <p>Vence en <strong>{EMAIL_CODE_TTL_MINUTES}</strong> minutos.</p>
        <p style='color:#666;font-size:12px'>Si no solicitaste este código, ignora este correo.</p>
    """

    try:
        send_email(user.email, subject, text, html)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Email send failed: {e}")

    # 6️⃣ Guardar el código en memoria (solo demo)
    _verif_store[user.email] = {
        "code": code,
        "expires": time.time() + (EMAIL_CODE_TTL_MINUTES * 60),
        "attempts": 0,
    }
    _last_send_epoch[user.email] = now

    # 7️⃣ Retornar el usuario (sin contraseña, gracias al esquema UserOut)
    return created

# ---------------------------------------------------------------------
# 🔹 Modelo para la verificación
# ---------------------------------------------------------------------
class VerifyIn(BaseModel):
    email: EmailStr
    code: str = Field(min_length=1, max_length=64)

# ---------------------------------------------------------------------
# 🔹 Endpoint: Verificar email con código
# ---------------------------------------------------------------------
@app.post("/api/users/verify")
def verify_email(payload: VerifyIn, db: Session = Depends(get_db)):
    """
    Verifica un código de correo y activa al usuario.
    """

    # 1️⃣ Verificar si existe un código pendiente
    rec = _verif_store.get(payload.email)
    if not rec:
        raise HTTPException(status_code=400, detail="No verification pending for this email")

    # 2️⃣ Verificar si el código está vencido
    if time.time() > rec["expires"]:
        _verif_store.pop(payload.email, None)
        raise HTTPException(status_code=400, detail="Code expired")

    # 3️⃣ Validar coincidencia del código
    if str(payload.code).strip() != str(rec["code"]):
        rec["attempts"] = rec.get("attempts", 0) + 1
        if rec["attempts"] >= 5:
            _verif_store.pop(payload.email, None)
            raise HTTPException(status_code=400, detail="Too many invalid attempts")
        raise HTTPException(status_code=400, detail="Invalid code")

    # 4️⃣ Activar el usuario en la base de datos
    user = crud.get_user_by_email(db, payload.email)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    user.active = True
    db.add(user)
    db.commit()
    db.refresh(user)

    # 5️⃣ Eliminar el código (ya usado)
    _verif_store.pop(payload.email, None)

    return {
        "status": "ok",
        "message": "Email verified. User activated.",
        "user_id": str(user.id),
    }

# ---------------------------------------------------------------------
# 🔹 Endpoint: Actualizar usuario
# ---------------------------------------------------------------------
@app.put("/api/users/{user_id}", response_model=schemas.UserOut)
def update_user(user_id: UUID, user: schemas.UserUpdate, db: Session = Depends(get_db)):
    """
    Actualiza datos del usuario, validando correos repetidos.
    """
    if user.email:
        existing = crud.get_user_by_email(db, user.email)
        if existing and existing.id != user_id:
            raise HTTPException(status_code=400, detail="Email already in use")

    updated = crud.update_user(db, user_id, user)
    if not updated:
        raise HTTPException(status_code=404, detail="User not found")

    return updated
===== app/services/emailer.py =====
"""
Servicio de envío de correos vía SMTP (por ejemplo Gmail).
Usa App Password de 16 caracteres (variable de entorno SMTP_PASS).
"""

import os
import ssl
import smtplib
from email.message import EmailMessage

# Configuración desde .env
SMTP_HOST = os.getenv("SMTP_HOST", "smtp.gmail.com")   # Servidor SMTP
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))         # Puerto STARTTLS
SMTP_USER = os.getenv("SMTP_USER")                     # Cuenta de correo remitente
SMTP_PASS = os.getenv("SMTP_PASS")                     # App Password
EMAIL_FROM = os.getenv("EMAIL_FROM", SMTP_USER)        # Nombre visible del remitente

def send_email(to_email: str, subject: str, text_body: str, html_body: str | None = None) -> None:
    """
    Envía un correo con versión texto y opcionalmente HTML.
    Lanza excepción si falla.
    """

    # 1️⃣ Validar credenciales
    if not SMTP_USER or not SMTP_PASS:
        raise RuntimeError("SMTP_USER/SMTP_PASS no configurados en .env")

    # 2️⃣ Crear el mensaje de correo
    msg = EmailMessage()
    msg["From"] = EMAIL_FROM or SMTP_USER
    msg["To"] = to_email
    msg["Subject"] = subject
    msg.set_content(text_body)
    if html_body:
        msg.add_alternative(html_body, subtype="html")

    # 3️⃣ Conectar al servidor y enviar
    with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as s:
        s.starttls(context=ssl.create_default_context())  # conexión segura
        s.login(SMTP_USER, SMTP_PASS)                     # autenticación
        s.send_message(msg)                               # enviar mensaje
===== app/crud.py =====
from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from sqlalchemy.orm import Session

from . import models, schemas
from .security import get_password_hash


def get_users(db: Session, skip: int = 0, limit: int = 100) -> List[models.User]:
    return (
        db.query(models.User)
        .order_by(models.User.created_at.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )


def get_user(db: Session, user_id: UUID) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.id == user_id).first()


def get_user_by_email(db: Session, email: str) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.email == email).first()


def create_user(db: Session, user_in: schemas.UserCreate, password_hash: str) -> models.User:
    u = models.User(
        email=user_in.email,
        first_name=user_in.first_name,
        last_name=user_in.last_name,
        phone=user_in.phone,
        is_company=user_in.is_company,
        company_name=user_in.company_name if user_in.is_company else None,
        password_hash=password_hash,
        active=False,
    )
    db.add(u)
    db.commit()
    db.refresh(u)
    return u


def update_user(
    db: Session, user_id: UUID, user_in: schemas.UserUpdate
) -> Optional[models.User]:
    u = get_user(db, user_id)
    if not u:
        return None

    # Campos planos
    for attr in ("email", "first_name", "last_name", "phone", "is_company", "company_name"):
        value = getattr(user_in, attr)
        if value is not None:
            setattr(u, attr, value)

    # Si pasa is_company = False, company_name debe quedar en None
    if user_in.is_company is False:
        u.company_name = None

    # Cambio de password
    if user_in.password:
        u.password_hash = get_password_hash(user_in.password)

    db.add(u)
    db.commit()
    db.refresh(u)
    return u



===== app/models.py =====
from sqlalchemy import Column, String, Boolean, DateTime, func, text
from sqlalchemy.dialects.postgresql import UUID
from .db import Base
import uuid

class User(Base):
    __tablename__ = "users"
    __table_args__ = {"schema": "conexion_carga"}

    id = Column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,                         # default en la app
        server_default=text("uuid_generate_v4()"),  # default en la BD
        nullable=False,
    )
    email = Column(String(255), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    first_name = Column(String(120), nullable=False)
    last_name = Column(String(120), nullable=False)
    phone = Column(String(30), nullable=True)

    is_company = Column(Boolean, nullable=False, server_default=text("false"))
    company_name = Column(String(255), nullable=True)

    active = Column(Boolean, nullable=False, server_default=text("true"))
    created_at = Column(DateTime(timezone=False), nullable=False, server_default=func.now())
===== app/schemas.py =====
# app/schemas.py
from datetime import datetime
from typing import Optional
from uuid import UUID

from pydantic import BaseModel, EmailStr, Field

# --- Compat layer para Pydantic v1/v2 ---
# - En v2 usamos model_validator (after)
# - En v1 caemos a root_validator
try:
    from pydantic import model_validator  # v2
    PVD = 2
except Exception:  # v1
    from pydantic import root_validator   # type: ignore
    PVD = 1


# ---------- Create ----------
class UserCreate(BaseModel):
    email: EmailStr
    first_name: str
    last_name: str
    phone: Optional[str] = None
    is_company: bool = False
    company_name: Optional[str] = None
    password: str = Field(min_length=8)
    confirm_password: str

    if PVD == 2:
        @model_validator(mode="after")
        def _v2_passwords_match(self):
            if self.password != self.confirm_password:
                raise ValueError("password and confirm_password must match")
            return self

        @model_validator(mode="after")
        def _v2_normalize_company(self):
            if not self.is_company:
                object.__setattr__(self, "company_name", None)
            else:
                if not (self.company_name and self.company_name.strip()):
                    raise ValueError("company_name is required when is_company=True")
            return self
    else:
        @root_validator  # type: ignore
        def _v1_normalize_and_validate(cls, values):
            if values.get("password") != values.get("confirm_password"):
                raise ValueError("password and confirm_password must match")
            if not values.get("is_company"):
                values["company_name"] = None
            else:
                cn = values.get("company_name")
                if not (cn and cn.strip()):
                    raise ValueError("company_name is required when is_company=True")
            return values


# ---------- Update ----------
class UserUpdate(BaseModel):
    # Todos opcionales para partial update
    email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    phone: Optional[str] = None
    is_company: Optional[bool] = None
    company_name: Optional[str] = None
    password: Optional[str] = Field(default=None, min_length=8)
    confirm_password: Optional[str] = None

    if PVD == 2:
        from pydantic import model_validator  # type: ignore

        @model_validator(mode="after")
        def _v2_passwords_match(self):
            # Si cambian la clave, deben venir ambos y ser iguales
            if (self.password is not None or self.confirm_password is not None) and (
                self.password != self.confirm_password
            ):
                raise ValueError("password and confirm_password must match")
            return self

        @model_validator(mode="after")
        def _v2_normalize_company(self):
            if self.is_company is False:
                object.__setattr__(self, "company_name", None)
            if self.is_company is True and self.company_name is not None and not self.company_name.strip():
                raise ValueError("company_name must not be empty when is_company=True")
            return self
    else:
        @root_validator  # type: ignore
        def _v1_normalize_and_validate(cls, values):
            pw, cpw = values.get("password"), values.get("confirm_password")
            if (pw is not None or cpw is not None) and pw != cpw:
                raise ValueError("password and confirm_password must match")
            if values.get("is_company") is False:
                values["company_name"] = None
            if values.get("is_company") is True and values.get("company_name") is not None:
                if not values["company_name"].strip():
                    raise ValueError("company_name must not be empty when is_company=True")
            return values


# ---------- Out ----------
class UserOut(BaseModel):
    id: UUID
    email: EmailStr
    first_name: str
    last_name: str
    phone: Optional[str] = None
    is_company: bool
    company_name: Optional[str] = None
    active: bool
    created_at: datetime

    class Config:
        # v2 (from_attributes) y v1 (orm_mode) para compatibilidad
        try:
            from_attributes = True  # v2
        except Exception:
            orm_mode = True         # v1
===== app/__init__.py =====
===== app/security.py =====
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    return pwd_context.verify(plain, hashed)
===== app/db.py =====
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

load_dotenv()

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql+psycopg2://infinity:infinity@localhost/conexion_carga"
)

engine = create_engine(DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
